<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArduinoGHTTP: ghttp::HTTPResponse&lt; S &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygenstyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ghttp_chrome_opt.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ArduinoGHTTP
   &#160;<span id="projectnumber">release_100-e1d212a(git)</span>
   </div>
   <div id="projectbrief">Embedded library for parsing HTTP requests and creating responses, supporting Arduino, portable (GPL).</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classghttp_1_1_h_t_t_p_response.htm',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classghttp_1_1_h_t_t_p_response-members.htm">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ghttp::HTTPResponse&lt; S &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>HTTP Response class with helpers to assist in the construction of valid HTTP response messages.  
 <a href="classghttp_1_1_h_t_t_p_response.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ghttp__httpresponse_8h_source.htm">core/ghttp_httpresponse.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0710f3117e28ea11f0a37ea81e78301"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#ab0710f3117e28ea11f0a37ea81e78301">HTTPResponse</a> ()</td></tr>
<tr class="memdesc:ab0710f3117e28ea11f0a37ea81e78301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, make stable instance.  <a href="classghttp_1_1_h_t_t_p_response.htm#ab0710f3117e28ea11f0a37ea81e78301">More...</a><br /></td></tr>
<tr class="separator:ab0710f3117e28ea11f0a37ea81e78301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0ec3765aa6be40717f4bf0366aaadd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#acd0ec3765aa6be40717f4bf0366aaadd">HTTPResponse</a> (char *<a class="el" href="ghttp__static__pre__route__request__response_8ino.htm#aad6df635ec0b9820ef1ee069e0263614">buffer</a>, uint16_t max_length, uint16_t length=0, uint16_t offset=0)</td></tr>
<tr class="memdesc:acd0ec3765aa6be40717f4bf0366aaadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, make stable instance, includes response buffer characteristics.  <a href="classghttp_1_1_h_t_t_p_response.htm#acd0ec3765aa6be40717f4bf0366aaadd">More...</a><br /></td></tr>
<tr class="separator:acd0ec3765aa6be40717f4bf0366aaadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d07b723f9091a955958abb4bece6047"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a2d07b723f9091a955958abb4bece6047">GetContentLength</a> () const</td></tr>
<tr class="memdesc:a2d07b723f9091a955958abb4bece6047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return content length - headers.  <a href="classghttp_1_1_h_t_t_p_response.htm#a2d07b723f9091a955958abb4bece6047">More...</a><br /></td></tr>
<tr class="separator:a2d07b723f9091a955958abb4bece6047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3166e1fd8162b90ac6d7d59479f3afeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a3166e1fd8162b90ac6d7d59479f3afeb">Header</a> (const char *header_str, const bool replace=true)</td></tr>
<tr class="memdesc:a3166e1fd8162b90ac6d7d59479f3afeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Response header string, append with optional replace.  <a href="classghttp_1_1_h_t_t_p_response.htm#a3166e1fd8162b90ac6d7d59479f3afeb">More...</a><br /></td></tr>
<tr class="separator:a3166e1fd8162b90ac6d7d59479f3afeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871fe05aae80d6e0f90e2037486b845d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a871fe05aae80d6e0f90e2037486b845d">HeaderForStatus</a> (const char *protocol_str)</td></tr>
<tr class="memdesc:a871fe05aae80d6e0f90e2037486b845d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header for status, caller should provide protocol and protocol version information for header string construction.  <a href="classghttp_1_1_h_t_t_p_response.htm#a871fe05aae80d6e0f90e2037486b845d">More...</a><br /></td></tr>
<tr class="separator:a871fe05aae80d6e0f90e2037486b845d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f555f1c86bc778bcfef48b1ca7ad20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#ae4f555f1c86bc778bcfef48b1ca7ad20">HeaderRemove</a> (const char *header_str, const bool all=true)</td></tr>
<tr class="memdesc:ae4f555f1c86bc778bcfef48b1ca7ad20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header remove by given header name string.  <a href="classghttp_1_1_h_t_t_p_response.htm#ae4f555f1c86bc778bcfef48b1ca7ad20">More...</a><br /></td></tr>
<tr class="separator:ae4f555f1c86bc778bcfef48b1ca7ad20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fcd2cf5ab93473c6bffb4ad21694e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#ae5fcd2cf5ab93473c6bffb4ad21694e4">NoContent</a> ()</td></tr>
<tr class="memdesc:ae5fcd2cf5ab93473c6bffb4ad21694e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force remove any existing content.  <a href="classghttp_1_1_h_t_t_p_response.htm#ae5fcd2cf5ab93473c6bffb4ad21694e4">More...</a><br /></td></tr>
<tr class="separator:ae5fcd2cf5ab93473c6bffb4ad21694e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d99122b8c97396e30859c8ba36582c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#aa2d99122b8c97396e30859c8ba36582c">HeaderComplete</a> (const char *session_id=NULL, const char *session_cookie_addition=NULL)</td></tr>
<tr class="memdesc:aa2d99122b8c97396e30859c8ba36582c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue header complete with optional session cookie id and any session cookie addition string.  <a href="classghttp_1_1_h_t_t_p_response.htm#aa2d99122b8c97396e30859c8ba36582c">More...</a><br /></td></tr>
<tr class="separator:aa2d99122b8c97396e30859c8ba36582c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa80b647d325fc9cae4fdfe4ff1d21f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#afa80b647d325fc9cae4fdfe4ff1d21f1">IsHeaderComplete</a> () const</td></tr>
<tr class="memdesc:afa80b647d325fc9cae4fdfe4ff1d21f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query are headers complete.  <a href="classghttp_1_1_h_t_t_p_response.htm#afa80b647d325fc9cae4fdfe4ff1d21f1">More...</a><br /></td></tr>
<tr class="separator:afa80b647d325fc9cae4fdfe4ff1d21f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac3524cafc8f767b980cd94822a9efa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a7ac3524cafc8f767b980cd94822a9efa">Complete</a> (const bool include_content_length=true)</td></tr>
<tr class="memdesc:a7ac3524cafc8f767b980cd94822a9efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete, invoke to indicate content complete.  <a href="classghttp_1_1_h_t_t_p_response.htm#a7ac3524cafc8f767b980cd94822a9efa">More...</a><br /></td></tr>
<tr class="separator:a7ac3524cafc8f767b980cd94822a9efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aee479571ef4f49d0dfd7fc8b811044"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a8aee479571ef4f49d0dfd7fc8b811044">GetEndOfHeaders</a> (const bool include_incomplete=false) const</td></tr>
<tr class="memdesc:a8aee479571ef4f49d0dfd7fc8b811044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get end of headers (character index)  <a href="classghttp_1_1_h_t_t_p_response.htm#a8aee479571ef4f49d0dfd7fc8b811044">More...</a><br /></td></tr>
<tr class="separator:a8aee479571ef4f49d0dfd7fc8b811044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcdf6c650da63c8caeb0b4842b3c26b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a4dcdf6c650da63c8caeb0b4842b3c26b">Header</a> (PGM_VOID_P header_str, const bool replace=true)</td></tr>
<tr class="memdesc:a4dcdf6c650da63c8caeb0b4842b3c26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Response header string, append with optional replace.  <a href="classghttp_1_1_h_t_t_p_response.htm#a4dcdf6c650da63c8caeb0b4842b3c26b">More...</a><br /></td></tr>
<tr class="separator:a4dcdf6c650da63c8caeb0b4842b3c26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c18cf0cf44ee46710d1931df180cfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a41c18cf0cf44ee46710d1931df180cfa">HeaderForStatus</a> (PGM_VOID_P protocol_str)</td></tr>
<tr class="memdesc:a41c18cf0cf44ee46710d1931df180cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header for status, caller should provide protocol and protocol version information for header string construction.  <a href="classghttp_1_1_h_t_t_p_response.htm#a41c18cf0cf44ee46710d1931df180cfa">More...</a><br /></td></tr>
<tr class="separator:a41c18cf0cf44ee46710d1931df180cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43828261a78c0295bd7bb18f2e9b0127"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a43828261a78c0295bd7bb18f2e9b0127">HeaderRemove</a> (PGM_VOID_P header_str, const bool all=true)</td></tr>
<tr class="memdesc:a43828261a78c0295bd7bb18f2e9b0127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header remove by given header name string.  <a href="classghttp_1_1_h_t_t_p_response.htm#a43828261a78c0295bd7bb18f2e9b0127">More...</a><br /></td></tr>
<tr class="separator:a43828261a78c0295bd7bb18f2e9b0127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classghttp_1_1_h_t_t_p_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classghttp_1_1_h_t_t_p_buffer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm">ghttp::HTTPBuffer</a></td></tr>
<tr class="memitem:a8af9de4e14113804f7dd131f2ef29fa7 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a8af9de4e14113804f7dd131f2ef29fa7">HTTPBuffer</a> ()</td></tr>
<tr class="memdesc:a8af9de4e14113804f7dd131f2ef29fa7 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, make stable instance.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a8af9de4e14113804f7dd131f2ef29fa7">More...</a><br /></td></tr>
<tr class="separator:a8af9de4e14113804f7dd131f2ef29fa7 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08158f4531e2874e50b6f4182cf04966 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a08158f4531e2874e50b6f4182cf04966">HTTPBuffer</a> (char *<a class="el" href="ghttp__static__pre__route__request__response_8ino.htm#aad6df635ec0b9820ef1ee069e0263614">buffer</a>, uint16_t max_length, uint16_t length=0, uint16_t offset=0)</td></tr>
<tr class="memdesc:a08158f4531e2874e50b6f4182cf04966 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, make stable instance.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a08158f4531e2874e50b6f4182cf04966">More...</a><br /></td></tr>
<tr class="separator:a08158f4531e2874e50b6f4182cf04966 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ef2438e1c7ae3953641b6fa310cddb inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#ac0ef2438e1c7ae3953641b6fa310cddb">Clear</a> (const bool zero_clear=false)</td></tr>
<tr class="memdesc:ac0ef2438e1c7ae3953641b6fa310cddb inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear buffer, includes characteristics like length and offset.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#ac0ef2438e1c7ae3953641b6fa310cddb">More...</a><br /></td></tr>
<tr class="separator:ac0ef2438e1c7ae3953641b6fa310cddb inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f97bb5d3220c9dde7b002a95f79aa24 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a9f97bb5d3220c9dde7b002a95f79aa24">At</a> (const uint16_t i) const</td></tr>
<tr class="memdesc:a9f97bb5d3220c9dde7b002a95f79aa24 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">At accessor.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a9f97bb5d3220c9dde7b002a95f79aa24">More...</a><br /></td></tr>
<tr class="separator:a9f97bb5d3220c9dde7b002a95f79aa24 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1170ca339ec7ad0b14946d923df595 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#acf1170ca339ec7ad0b14946d923df595">At</a> (const uint16_t i, char c)</td></tr>
<tr class="memdesc:acf1170ca339ec7ad0b14946d923df595 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">At accessor setter.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#acf1170ca339ec7ad0b14946d923df595">More...</a><br /></td></tr>
<tr class="separator:acf1170ca339ec7ad0b14946d923df595 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567f458970d2f3182f8d866da0708802 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a567f458970d2f3182f8d866da0708802"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classghttp_1_1_h_t_t_p_substring.htm">HTTPSubstring</a> &amp;rhs)</td></tr>
<tr class="separator:a567f458970d2f3182f8d866da0708802 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f14079ea832f40dc7ff78ba361d1a8 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a87f14079ea832f40dc7ff78ba361d1a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classghttp_1_1_h_t_t_p_substring.htm">HTTPSubstring</a> *rhs)</td></tr>
<tr class="separator:a87f14079ea832f40dc7ff78ba361d1a8 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ab287b3bd6073b3e0f1ae5c0fe13ab inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a61ab287b3bd6073b3e0f1ae5c0fe13ab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const char *rhs)</td></tr>
<tr class="separator:a61ab287b3bd6073b3e0f1ae5c0fe13ab inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aedbcd7d44b000f09f360cf4a6799e inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a98aedbcd7d44b000f09f360cf4a6799e"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const uint16_t &amp;rhs)</td></tr>
<tr class="separator:a98aedbcd7d44b000f09f360cf4a6799e inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99afbe2b1298d0891ae1f75f3fcbc1b inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="aa99afbe2b1298d0891ae1f75f3fcbc1b"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const uint16_t &amp;rhs)</td></tr>
<tr class="separator:aa99afbe2b1298d0891ae1f75f3fcbc1b inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509bf0ace750fa0458df946cfb62cb91 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a509bf0ace750fa0458df946cfb62cb91">operator[]</a> (const uint16_t i)</td></tr>
<tr class="memdesc:a509bf0ace750fa0458df946cfb62cb91 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index operator, use to access characters as alternative to <a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a9f97bb5d3220c9dde7b002a95f79aa24">At</a>.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a509bf0ace750fa0458df946cfb62cb91">More...</a><br /></td></tr>
<tr class="separator:a509bf0ace750fa0458df946cfb62cb91 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccfbecf78f865649933f4813c2d6a82 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#aaccfbecf78f865649933f4813c2d6a82">GetBuffer</a> () const</td></tr>
<tr class="memdesc:aaccfbecf78f865649933f4813c2d6a82 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get buffer.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#aaccfbecf78f865649933f4813c2d6a82">More...</a><br /></td></tr>
<tr class="separator:aaccfbecf78f865649933f4813c2d6a82 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28df8375d6824c339014a1f192aa1742 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a28df8375d6824c339014a1f192aa1742">SetBuffer</a> (char *<a class="el" href="ghttp__static__pre__route__request__response_8ino.htm#aad6df635ec0b9820ef1ee069e0263614">buffer</a>, uint16_t length=0, uint16_t offset=0)</td></tr>
<tr class="memdesc:a28df8375d6824c339014a1f192aa1742 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer Because Request and Responses may share the same buffer and some Request information maybe required for building a Response, use offset to keep required Request information buffered and usable while Response being built.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a28df8375d6824c339014a1f192aa1742">More...</a><br /></td></tr>
<tr class="separator:a28df8375d6824c339014a1f192aa1742 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9acfe159d320827ab76c9dbad00591e inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#ad9acfe159d320827ab76c9dbad00591e">GetOffset</a> () const</td></tr>
<tr class="memdesc:ad9acfe159d320827ab76c9dbad00591e inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#ad9acfe159d320827ab76c9dbad00591e">More...</a><br /></td></tr>
<tr class="separator:ad9acfe159d320827ab76c9dbad00591e inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf720940a9f2357e50f539f184dd8679 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#adf720940a9f2357e50f539f184dd8679">PrepareZeroOffsetData</a> ()</td></tr>
<tr class="memdesc:adf720940a9f2357e50f539f184dd8679 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare zero offset data.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#adf720940a9f2357e50f539f184dd8679">More...</a><br /></td></tr>
<tr class="separator:adf720940a9f2357e50f539f184dd8679 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb9acdefa93179e395c6c7d7d001244 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#aeeb9acdefa93179e395c6c7d7d001244">GetLength</a> () const</td></tr>
<tr class="memdesc:aeeb9acdefa93179e395c6c7d7d001244 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#aeeb9acdefa93179e395c6c7d7d001244">More...</a><br /></td></tr>
<tr class="separator:aeeb9acdefa93179e395c6c7d7d001244 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8111d390d405e2cb61728c0dbed4114 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#ac8111d390d405e2cb61728c0dbed4114">SetLength</a> (const uint16_t length, const bool ignore_maximum=false)</td></tr>
<tr class="memdesc:ac8111d390d405e2cb61728c0dbed4114 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set length.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#ac8111d390d405e2cb61728c0dbed4114">More...</a><br /></td></tr>
<tr class="separator:ac8111d390d405e2cb61728c0dbed4114 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69412ab74669a174f581f7c0349db233 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a69412ab74669a174f581f7c0349db233">GetMaximum</a> () const</td></tr>
<tr class="memdesc:a69412ab74669a174f581f7c0349db233 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get buffer maximum.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a69412ab74669a174f581f7c0349db233">More...</a><br /></td></tr>
<tr class="separator:a69412ab74669a174f581f7c0349db233 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef79015e1a8fb34dd96424849e510831 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#aef79015e1a8fb34dd96424849e510831">SetMaximum</a> (const uint16_t max_length)</td></tr>
<tr class="memdesc:aef79015e1a8fb34dd96424849e510831 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer maximum.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#aef79015e1a8fb34dd96424849e510831">More...</a><br /></td></tr>
<tr class="separator:aef79015e1a8fb34dd96424849e510831 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece2ac4a4458d8aa16731256dac64216 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#aece2ac4a4458d8aa16731256dac64216">Append</a> (const char *str, uint16_t length=0)</td></tr>
<tr class="memdesc:aece2ac4a4458d8aa16731256dac64216 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append character string.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#aece2ac4a4458d8aa16731256dac64216">More...</a><br /></td></tr>
<tr class="separator:aece2ac4a4458d8aa16731256dac64216 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c141425bc8656970d4d8e268fb7d74a inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a8c141425bc8656970d4d8e268fb7d74a">Append</a> (const uint8_t *data, uint16_t length)</td></tr>
<tr class="memdesc:a8c141425bc8656970d4d8e268fb7d74a inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append unsigned character array.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a8c141425bc8656970d4d8e268fb7d74a">More...</a><br /></td></tr>
<tr class="separator:a8c141425bc8656970d4d8e268fb7d74a inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a90814d09c0383bf85c65213869d41b inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a3a90814d09c0383bf85c65213869d41b">Append</a> (char ch)</td></tr>
<tr class="memdesc:a3a90814d09c0383bf85c65213869d41b inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append character.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a3a90814d09c0383bf85c65213869d41b">More...</a><br /></td></tr>
<tr class="separator:a3a90814d09c0383bf85c65213869d41b inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f23fe8e676cdaab57c98a3e9478e25d inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f23fe8e676cdaab57c98a3e9478e25d inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a4f23fe8e676cdaab57c98a3e9478e25d">AppendInt</a> (<a class="el" href="ghttp_8h.htm#a16a0f7e7053a679c9bf4289b441a2be7">T</a> v, uint8_t base=10)</td></tr>
<tr class="memdesc:a4f23fe8e676cdaab57c98a3e9478e25d inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append signed integer type T with given base.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a4f23fe8e676cdaab57c98a3e9478e25d">More...</a><br /></td></tr>
<tr class="separator:a4f23fe8e676cdaab57c98a3e9478e25d inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae752ad27af78588f467013e877a7ff80 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae752ad27af78588f467013e877a7ff80 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#ae752ad27af78588f467013e877a7ff80">AppendUInt</a> (<a class="el" href="ghttp_8h.htm#a16a0f7e7053a679c9bf4289b441a2be7">T</a> v, uint8_t base=10)</td></tr>
<tr class="memdesc:ae752ad27af78588f467013e877a7ff80 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append unsigned integer type T with given base.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#ae752ad27af78588f467013e877a7ff80">More...</a><br /></td></tr>
<tr class="separator:ae752ad27af78588f467013e877a7ff80 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8873883c5a9edd60c266755f5e36dc03 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8873883c5a9edd60c266755f5e36dc03 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a8873883c5a9edd60c266755f5e36dc03">AppendDecimal</a> (<a class="el" href="ghttp_8h.htm#a16a0f7e7053a679c9bf4289b441a2be7">T</a> v, uint8_t digits_below_dp=3, uint8_t str_allocation=16)</td></tr>
<tr class="memdesc:a8873883c5a9edd60c266755f5e36dc03 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append decimal type T with specific digits below decimal point.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a8873883c5a9edd60c266755f5e36dc03">More...</a><br /></td></tr>
<tr class="separator:a8873883c5a9edd60c266755f5e36dc03 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecdeda5ceb92a1000ac1dda97b94353 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a7ecdeda5ceb92a1000ac1dda97b94353">Insert</a> (uint16_t i, const char *str, uint16_t length=0)</td></tr>
<tr class="memdesc:a7ecdeda5ceb92a1000ac1dda97b94353 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert character string at specific index.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a7ecdeda5ceb92a1000ac1dda97b94353">More...</a><br /></td></tr>
<tr class="separator:a7ecdeda5ceb92a1000ac1dda97b94353 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd86c6d02110b0493787816b1d2452d inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a8dd86c6d02110b0493787816b1d2452d">InsertPadding</a> (uint16_t i, char c, uint16_t length)</td></tr>
<tr class="memdesc:a8dd86c6d02110b0493787816b1d2452d inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert padding character (a repeated character) at specific index to given length.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a8dd86c6d02110b0493787816b1d2452d">More...</a><br /></td></tr>
<tr class="separator:a8dd86c6d02110b0493787816b1d2452d inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343dafab39305d3dcf72c885a3b86693 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a343dafab39305d3dcf72c885a3b86693">Remove</a> (uint16_t i, uint16_t e)</td></tr>
<tr class="memdesc:a343dafab39305d3dcf72c885a3b86693 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove character(s) at specific start index to end index.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a343dafab39305d3dcf72c885a3b86693">More...</a><br /></td></tr>
<tr class="separator:a343dafab39305d3dcf72c885a3b86693 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab698dae0934552ac7b565011d9bab08f inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#ab698dae0934552ac7b565011d9bab08f">Replace</a> (uint16_t i, uint16_t e, const char *str, uint16_t length=0)</td></tr>
<tr class="memdesc:ab698dae0934552ac7b565011d9bab08f inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace character(s) at specific start index to end index with given character string.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#ab698dae0934552ac7b565011d9bab08f">More...</a><br /></td></tr>
<tr class="separator:ab698dae0934552ac7b565011d9bab08f inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133fa6599f1e5dccb9a13d0fbe7f742a inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a133fa6599f1e5dccb9a13d0fbe7f742a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (PGM_VOID_P rhs)</td></tr>
<tr class="separator:a133fa6599f1e5dccb9a13d0fbe7f742a inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac4adab9f43fffb8cf84dc8cdf9a645 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a0ac4adab9f43fffb8cf84dc8cdf9a645">Append</a> (PGM_VOID_P str, uint16_t length=0)</td></tr>
<tr class="memdesc:a0ac4adab9f43fffb8cf84dc8cdf9a645 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append character string.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a0ac4adab9f43fffb8cf84dc8cdf9a645">More...</a><br /></td></tr>
<tr class="separator:a0ac4adab9f43fffb8cf84dc8cdf9a645 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554536ffc0965d0724f537e20ceb3387 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a554536ffc0965d0724f537e20ceb3387">Insert</a> (uint16_t i, PGM_VOID_P str, uint16_t length=0)</td></tr>
<tr class="memdesc:a554536ffc0965d0724f537e20ceb3387 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert character string at specific index.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a554536ffc0965d0724f537e20ceb3387">More...</a><br /></td></tr>
<tr class="separator:a554536ffc0965d0724f537e20ceb3387 inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b40289f6622010843c02522c77b09ab inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a8b40289f6622010843c02522c77b09ab">Replace</a> (uint16_t i, uint16_t e, PGM_VOID_P str, uint16_t length=0)</td></tr>
<tr class="memdesc:a8b40289f6622010843c02522c77b09ab inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace character(s) at specific start index to end index with given character string.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a8b40289f6622010843c02522c77b09ab">More...</a><br /></td></tr>
<tr class="separator:a8b40289f6622010843c02522c77b09ab inherit pub_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afa8a87b80e833d7d8541741987f56119"><td class="memItemLeft" align="right" valign="top"><a id="afa8a87b80e833d7d8541741987f56119"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#afa8a87b80e833d7d8541741987f56119">status</a></td></tr>
<tr class="memdesc:afa8a87b80e833d7d8541741987f56119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status code instance. <br /></td></tr>
<tr class="separator:afa8a87b80e833d7d8541741987f56119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a20c669d4bb96082eac84fe6bb1201472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a20c669d4bb96082eac84fe6bb1201472">HeaderSet</a> (const char *header_str, const bool replace=true)</td></tr>
<tr class="memdesc:a20c669d4bb96082eac84fe6bb1201472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set response header string, append with optional replace.  <a href="classghttp_1_1_h_t_t_p_response.htm#a20c669d4bb96082eac84fe6bb1201472">More...</a><br /></td></tr>
<tr class="separator:a20c669d4bb96082eac84fe6bb1201472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acd5e10f0e2ecb815737f9f8f6658d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a0acd5e10f0e2ecb815737f9f8f6658d2">HeaderRemoveForce</a> (const char *header_str, const bool all=true)</td></tr>
<tr class="memdesc:a0acd5e10f0e2ecb815737f9f8f6658d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header remove by given header name string.  <a href="classghttp_1_1_h_t_t_p_response.htm#a0acd5e10f0e2ecb815737f9f8f6658d2">More...</a><br /></td></tr>
<tr class="separator:a0acd5e10f0e2ecb815737f9f8f6658d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2118f1f8af54c8201dde162b841fe944"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a2118f1f8af54c8201dde162b841fe944">HeaderSet</a> (PGM_VOID_P header_str, const bool replace=true)</td></tr>
<tr class="memdesc:a2118f1f8af54c8201dde162b841fe944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set response header string, append with optional replace.  <a href="classghttp_1_1_h_t_t_p_response.htm#a2118f1f8af54c8201dde162b841fe944">More...</a><br /></td></tr>
<tr class="separator:a2118f1f8af54c8201dde162b841fe944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb706035f5b0932e7aea73d5cd9eba2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm#aeb706035f5b0932e7aea73d5cd9eba2b">HeaderRemoveForce</a> (PGM_VOID_P header_str, const bool all=true)</td></tr>
<tr class="memdesc:aeb706035f5b0932e7aea73d5cd9eba2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header remove by given header name string.  <a href="classghttp_1_1_h_t_t_p_response.htm#aeb706035f5b0932e7aea73d5cd9eba2b">More...</a><br /></td></tr>
<tr class="separator:aeb706035f5b0932e7aea73d5cd9eba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classghttp_1_1_h_t_t_p_buffer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classghttp_1_1_h_t_t_p_buffer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm">ghttp::HTTPBuffer</a></td></tr>
<tr class="memitem:ad92fe71a7a36780718d9e044ab314c4a inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#ad92fe71a7a36780718d9e044ab314c4a">FindEOL</a> (uint16_t i, uint16_t ei) const</td></tr>
<tr class="memdesc:ad92fe71a7a36780718d9e044ab314c4a inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find end of line.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#ad92fe71a7a36780718d9e044ab314c4a">More...</a><br /></td></tr>
<tr class="separator:ad92fe71a7a36780718d9e044ab314c4a inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3edcde6636f7e28e3fb2fd54dbb97cc inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#af3edcde6636f7e28e3fb2fd54dbb97cc">FindSubString</a> (uint16_t i, uint16_t ei, const char *str, uint16_t str_length_max=0) const</td></tr>
<tr class="memdesc:af3edcde6636f7e28e3fb2fd54dbb97cc inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a substring, case sensitive.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#af3edcde6636f7e28e3fb2fd54dbb97cc">More...</a><br /></td></tr>
<tr class="separator:af3edcde6636f7e28e3fb2fd54dbb97cc inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4f3bdf890006fe8d46d34ee163929a inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a7a4f3bdf890006fe8d46d34ee163929a">FindTerminator</a> (uint16_t i, const char *include_special, bool invert_special_only=false, uint16_t i_max=0) const</td></tr>
<tr class="memdesc:a7a4f3bdf890006fe8d46d34ee163929a inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find terminator characters.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a7a4f3bdf890006fe8d46d34ee163929a">More...</a><br /></td></tr>
<tr class="separator:a7a4f3bdf890006fe8d46d34ee163929a inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cb111c718d0c26f0d1efc7b61efac7 inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a97cb111c718d0c26f0d1efc7b61efac7">FindSubString</a> (uint16_t i, uint16_t ei, PGM_VOID_P str, uint16_t str_length_max=0) const</td></tr>
<tr class="memdesc:a97cb111c718d0c26f0d1efc7b61efac7 inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a substring, case sensitive.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a97cb111c718d0c26f0d1efc7b61efac7">More...</a><br /></td></tr>
<tr class="separator:a97cb111c718d0c26f0d1efc7b61efac7 inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d3f2678d4517ec203098adaeab7668 inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a80d3f2678d4517ec203098adaeab7668">FindTerminator</a> (uint16_t i, PGM_VOID_P include_special, bool invert_special_only=false, uint16_t i_max=0) const</td></tr>
<tr class="memdesc:a80d3f2678d4517ec203098adaeab7668 inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find terminator characters.  <a href="classghttp_1_1_h_t_t_p_buffer.htm#a80d3f2678d4517ec203098adaeab7668">More...</a><br /></td></tr>
<tr class="separator:a80d3f2678d4517ec203098adaeab7668 inherit pro_methods_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classghttp_1_1_h_t_t_p_buffer')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm">ghttp::HTTPBuffer</a></td></tr>
<tr class="memitem:af9c6fd75b8e2c829e43b086381e20b39 inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="af9c6fd75b8e2c829e43b086381e20b39"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#af9c6fd75b8e2c829e43b086381e20b39">length_</a></td></tr>
<tr class="memdesc:af9c6fd75b8e2c829e43b086381e20b39 inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data in buffer, length in characters. <br /></td></tr>
<tr class="separator:af9c6fd75b8e2c829e43b086381e20b39 inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c35bfb11f81b600251c629fc55b61d0 inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a4c35bfb11f81b600251c629fc55b61d0"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a4c35bfb11f81b600251c629fc55b61d0">max_length_</a></td></tr>
<tr class="memdesc:a4c35bfb11f81b600251c629fc55b61d0 inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum data in buffer in characters. <br /></td></tr>
<tr class="separator:a4c35bfb11f81b600251c629fc55b61d0 inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cbb4e3a4546ac49de67f1ba3756bda inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="ad0cbb4e3a4546ac49de67f1ba3756bda"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#ad0cbb4e3a4546ac49de67f1ba3756bda">offset_</a></td></tr>
<tr class="memdesc:ad0cbb4e3a4546ac49de67f1ba3756bda inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset (characters) of unused head of buffer. <br /></td></tr>
<tr class="separator:ad0cbb4e3a4546ac49de67f1ba3756bda inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63c63abb009ad0de97aee89ef979fd0 inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="memItemLeft" align="right" valign="top"><a id="af63c63abb009ad0de97aee89ef979fd0"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#af63c63abb009ad0de97aee89ef979fd0">buffer_</a></td></tr>
<tr class="memdesc:af63c63abb009ad0de97aee89ef979fd0 inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character buffer pointer. <br /></td></tr>
<tr class="separator:af63c63abb009ad0de97aee89ef979fd0 inherit pro_attribs_classghttp_1_1_h_t_t_p_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class S&gt;<br />
class ghttp::HTTPResponse&lt; S &gt;</h3>

<p>HTTP Response class with helpers to assist in the construction of valid HTTP response messages. </p>
<p>The resulting data in <a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm" title="A class for character buffering with an interface for string manipulation used during both request an...">HTTPBuffer</a> should be sent over TCP/IP. It is expected that this will all be after handling a HTTP request</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>Status code class used in response </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab0710f3117e28ea11f0a37ea81e78301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0710f3117e28ea11f0a37ea81e78301">&#9670;&nbsp;</a></span>HTTPResponse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::<a class="el" href="classghttp_1_1_h_t_t_p_response.htm">HTTPResponse</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, make stable instance. </p>
<p>Buffer setup with 0 length and NULL pointer</p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#a28df8375d6824c339014a1f192aa1742">SetBuffer</a> to setup the response buffer characteristics </dd></dl>

</div>
</div>
<a id="acd0ec3765aa6be40717f4bf0366aaadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0ec3765aa6be40717f4bf0366aaadd">&#9670;&nbsp;</a></span>HTTPResponse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::<a class="el" href="classghttp_1_1_h_t_t_p_response.htm">HTTPResponse</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor, make stable instance, includes response buffer characteristics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer String pointer to buffer first character </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_length</td><td>Buffer maximum length (including NULL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Buffer current length (if data exists already), default 0 (characters) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset (characters) from buffer[0] to allow request header and other request data access during construction of response. Default 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ac3524cafc8f767b980cd94822a9efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac3524cafc8f767b980cd94822a9efa">&#9670;&nbsp;</a></span>Complete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::Complete </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>include_content_length</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complete, invoke to indicate content complete. </p>
<dl class="section note"><dt>Note</dt><dd>Make sure you have appended all request data prior to invoke </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Invoke after <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#aa2d99122b8c97396e30859c8ba36582c">HeaderComplete</a> </dd>
<dd>
<a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm#adf720940a9f2357e50f539f184dd8679" title="Prepare zero offset data.">HTTPBuffer::PrepareZeroOffsetData</a> invoked internally when result yields true </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false. In the latter case make sure headers are complete prior </dd></dl>

</div>
</div>
<a id="a2d07b723f9091a955958abb4bece6047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d07b723f9091a955958abb4bece6047">&#9670;&nbsp;</a></span>GetContentLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::GetContentLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and return content length - headers. </p>
<p>It is assumed response headers are complete when content exists</p>
<dl class="section return"><dt>Returns</dt><dd>Content length (characters) </dd></dl>

</div>
</div>
<a id="a8aee479571ef4f49d0dfd7fc8b811044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aee479571ef4f49d0dfd7fc8b811044">&#9670;&nbsp;</a></span>GetEndOfHeaders()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::GetEndOfHeaders </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>include_incomplete</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get end of headers (character index) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">include_incomplete</td><td>Flag indicating a length required even if headers are not complete. Default false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Character index into <a class="el" href="classghttp_1_1_h_t_t_p_buffer.htm" title="A class for character buffering with an interface for string manipulation used during both request an...">HTTPBuffer</a> where next append should be made </dd></dl>

</div>
</div>
<a id="a3166e1fd8162b90ac6d7d59479f3afeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3166e1fd8162b90ac6d7d59479f3afeb">&#9670;&nbsp;</a></span>Header() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::Header </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Response header string, append with optional replace. </p>
<dl class="section note"><dt>Note</dt><dd>Can be used to set status header (line). When doing so pass protocol and version only like "HTTP/1.0" etc. </dd>
<dd>
Besides the status header, all other headers must be complete. No header should include newline or carriage return </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Use until <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#aa2d99122b8c97396e30859c8ba36582c">HeaderComplete</a> has been invoked. Also if there is any content length do not attempt to add headers</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_str</td><td>Header string pointer (NULL terminated). Header format is "&lt;name&gt;: &lt;data&gt;" unless setting status header </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace</td><td>Flag indicating replacement, default true. When true all other like headers will be removed prior to new insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="a4dcdf6c650da63c8caeb0b4842b3c26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcdf6c650da63c8caeb0b4842b3c26b">&#9670;&nbsp;</a></span>Header() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::Header </td>
          <td>(</td>
          <td class="paramtype">PGM_VOID_P&#160;</td>
          <td class="paramname"><em>header_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Response header string, append with optional replace. </p>
<dl class="section note"><dt>Note</dt><dd>Can be used to set status header (line). When doing so pass protocol and version only like "HTTP/1.0" etc. </dd>
<dd>
Besides the status header, all other headers must be complete. No header should include newline or carriage return </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Use until <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#aa2d99122b8c97396e30859c8ba36582c">HeaderComplete</a> has been invoked. Also if there is any content length do not attempt to add headers</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_str</td><td>Header string pointer (NULL terminated, flash based). Header format is "&lt;name&gt;: &lt;data&gt;" unless setting status header </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace</td><td>Flag indicating replacement, default true. When true all other like headers will be removed prior to new insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="aa2d99122b8c97396e30859c8ba36582c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d99122b8c97396e30859c8ba36582c">&#9670;&nbsp;</a></span>HeaderComplete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::HeaderComplete </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>session_id</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>session_cookie_addition</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issue header complete with optional session cookie id and any session cookie addition string. </p>
<dl class="section attention"><dt>Attention</dt><dd>Invoke before <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a7ac3524cafc8f767b980cd94822a9efa">Complete</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session_id</td><td>String pointer, obtained from request session (if any). Default NULL =&gt; no session cookie addition upon header completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">session_cookie_addition</td><td>String pointer. Only used session_id string setup. Default NULL =&gt; no addition. Example might be "HttpOnly" etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="a871fe05aae80d6e0f90e2037486b845d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871fe05aae80d6e0f90e2037486b845d">&#9670;&nbsp;</a></span>HeaderForStatus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::HeaderForStatus </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>protocol_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Header for status, caller should provide protocol and protocol version information for header string construction. </p>
<dl class="todo"><dt><b><a class="el" href="todo.htm#_todo000002">Todo:</a></b></dt><dd>Refactor with <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#ae4f555f1c86bc778bcfef48b1ca7ad20">HeaderRemove</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol_str</td><td>Protocol (including version) string pointer. Format like "HTTP/1.0" etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="a41c18cf0cf44ee46710d1931df180cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c18cf0cf44ee46710d1931df180cfa">&#9670;&nbsp;</a></span>HeaderForStatus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::HeaderForStatus </td>
          <td>(</td>
          <td class="paramtype">PGM_VOID_P&#160;</td>
          <td class="paramname"><em>protocol_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Header for status, caller should provide protocol and protocol version information for header string construction. </p>
<dl class="todo"><dt><b><a class="el" href="todo.htm#_todo000003">Todo:</a></b></dt><dd>Refactor with <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#ae4f555f1c86bc778bcfef48b1ca7ad20">HeaderRemove</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol_str</td><td>Protocol (including version) string pointer, flash based. Format like "HTTP/1.0" etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="ae4f555f1c86bc778bcfef48b1ca7ad20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f555f1c86bc778bcfef48b1ca7ad20">&#9670;&nbsp;</a></span>HeaderRemove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::HeaderRemove </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Header remove by given header name string. </p>
<p>Optionally removes all like headers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_str</td><td>String pointer to header name (NULL terminated). This can be entire header or string before colon (the name). The former case only the name is matched not the header data during removal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all</td><td>Flag to remove all or first matching header, default true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="a43828261a78c0295bd7bb18f2e9b0127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43828261a78c0295bd7bb18f2e9b0127">&#9670;&nbsp;</a></span>HeaderRemove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::HeaderRemove </td>
          <td>(</td>
          <td class="paramtype">PGM_VOID_P&#160;</td>
          <td class="paramname"><em>header_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Header remove by given header name string. </p>
<p>Optionally removes all like headers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_str</td><td>String pointer to header name (NULL terminated, flash based). This can be entire header or string before colon (the name). The former case only the name is matched not the header data during removal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all</td><td>Flag to remove all or first matching header, default true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="a0acd5e10f0e2ecb815737f9f8f6658d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acd5e10f0e2ecb815737f9f8f6658d2">&#9670;&nbsp;</a></span>HeaderRemoveForce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::HeaderRemoveForce </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Header remove by given header name string. </p>
<p>Optionally removes all like headers and has less restrictions than <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#ae4f555f1c86bc778bcfef48b1ca7ad20">HeaderRemove</a></p>
<dl class="section note"><dt>Note</dt><dd>Can remove even after headers complete</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_str</td><td>String pointer to header name (NULL terminated). This can be entire header or string before colon (the name). The former case only the name is matched not the header data during removal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all</td><td>Flag to remove all or first matching header, default true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="aeb706035f5b0932e7aea73d5cd9eba2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb706035f5b0932e7aea73d5cd9eba2b">&#9670;&nbsp;</a></span>HeaderRemoveForce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::HeaderRemoveForce </td>
          <td>(</td>
          <td class="paramtype">PGM_VOID_P&#160;</td>
          <td class="paramname"><em>header_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Header remove by given header name string. </p>
<p>Optionally removes all like headers and has less restrictions than <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#ae4f555f1c86bc778bcfef48b1ca7ad20">HeaderRemove</a></p>
<dl class="section note"><dt>Note</dt><dd>Can remove even after headers complete</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_str</td><td>String pointer to header name (NULL terminated, flash based). This can be entire header or string before colon (the name). The former case only the name is matched not the header data during removal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all</td><td>Flag to remove all or first matching header, default true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="a20c669d4bb96082eac84fe6bb1201472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c669d4bb96082eac84fe6bb1201472">&#9670;&nbsp;</a></span>HeaderSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::HeaderSet </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set response header string, append with optional replace. </p>
<p>Employed internally for header setting and has less restrictions than <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a3166e1fd8162b90ac6d7d59479f3afeb">Header</a></p>
<dl class="section note"><dt>Note</dt><dd>May have partly set header or removed existing upon failure </dd>
<dd>
Can be used to set status header (line). When doing so pass protocol and version only like "HTTP/1.0" etc. </dd>
<dd>
Besides the status header, all other headers must be complete. No header should include newline or carriage return</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_str</td><td>Header string pointer (NULL terminated). Header format is "&lt;name&gt;: &lt;data&gt;" unless setting status header </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace</td><td>Flag indicating replacement, default true. When true all other like headers will be removed prior to new insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="a2118f1f8af54c8201dde162b841fe944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2118f1f8af54c8201dde162b841fe944">&#9670;&nbsp;</a></span>HeaderSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::HeaderSet </td>
          <td>(</td>
          <td class="paramtype">PGM_VOID_P&#160;</td>
          <td class="paramname"><em>header_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set response header string, append with optional replace. </p>
<p>Employed internally for header setting and has less restrictions than <a class="el" href="classghttp_1_1_h_t_t_p_response.htm#a3166e1fd8162b90ac6d7d59479f3afeb">Header</a></p>
<dl class="section note"><dt>Note</dt><dd>May have partly set header or removed existing upon failure </dd>
<dd>
Can be used to set status header (line). When doing so pass protocol and version only like "HTTP/1.0" etc. </dd>
<dd>
Besides the status header, all other headers must be complete. No header should include newline or carriage return</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_str</td><td>Header string pointer (NULL terminated, flash based). Header format is "&lt;name&gt;: &lt;data&gt;" unless setting status header </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace</td><td>Flag indicating replacement, default true. When true all other like headers will be removed prior to new insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
<a id="afa80b647d325fc9cae4fdfe4ff1d21f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa80b647d325fc9cae4fdfe4ff1d21f1">&#9670;&nbsp;</a></span>IsHeaderComplete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::IsHeaderComplete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query are headers complete. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>When final CR+LF included and content start present </td></tr>
    <tr><td class="paramname">false</td><td>When headers not complete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5fcd2cf5ab93473c6bffb4ad21694e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fcd2cf5ab93473c6bffb4ad21694e4">&#9670;&nbsp;</a></span>NoContent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghttp_1_1_h_t_t_p_response.htm">ghttp::HTTPResponse</a>&lt; S &gt;::NoContent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force remove any existing content. </p>
<dl class="section attention"><dt>Attention</dt><dd>Does nothing if not content exists. After content removed, header complete still remains </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>State, true on success otherwise false </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ghttp</b></li><li class="navelem"><a class="el" href="classghttp_1_1_h_t_t_p_response.htm">HTTPResponse</a></li>
    <li class="footer">Generated on Mon Jan 1 2024 16:37:30 for ArduinoGHTTP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
